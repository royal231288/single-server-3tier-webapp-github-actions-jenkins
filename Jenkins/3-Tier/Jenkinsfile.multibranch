// Jenkinsfile.multibranch
// Multibranch pipeline for deploying to different environments based on branch
// Branches: main (production), staging (staging), develop (development)

pipeline {
    agent any
    
    parameters {
        booleanParam(
            name: 'DEPLOY_BACKEND_ONLY',
            defaultValue: false,
            description: 'Deploy only backend (skip frontend deployment)'
        )
        booleanParam(
            name: 'DEPLOY_FRONTEND_ONLY',
            defaultValue: false,
            description: 'Deploy only frontend (skip backend deployment)'
        )
        booleanParam(
            name: 'SKIP_HEALTH_CHECK',
            defaultValue: false,
            description: 'Skip health checks after deployment'
        )
    }
    
    environment {
        // Git repository
        REPO_URL = 'https://github.com/your-username/single-server-3tier-webapp-github-actions.git'
        
        // Common configuration
        EC2_USER = 'ubuntu'
        EC2_SSH_KEY_ID = 'ec2-ssh-key'
        DEPLOY_BASE_PATH = '/home/ubuntu'
        BACKUP_BASE_PATH = '/home/ubuntu/bmi_deployments_backup'
        
        // Application configuration
        APP_NAME = 'bmi-health-tracker'
        PM2_PROCESS_NAME = 'bmi-backend'
        
        // Database configuration
        DB_NAME = 'bmidb'
        DB_USER = 'bmi_user'
        DB_HOST = 'localhost'
        DB_PORT = '5432'
        
        // Backend configuration
        BACKEND_PORT = '3000'
        
        // Build metadata
        BUILD_TIMESTAMP = sh(script: 'date +%Y%m%d_%H%M%S', returnStdout: true).trim()
    }
    
    stages {
        stage('Determine Environment') {
            steps {
                script {
                    echo '======================================'
                    echo 'ðŸŒ DETERMINING DEPLOYMENT ENVIRONMENT'
                    echo '======================================'
                    
                    // Determine environment based on branch
                    def branch = env.BRANCH_NAME
                    echo "Current branch: ${branch}"
                    
                    switch(branch) {
                        case 'main':
                        case 'master':
                            env.ENVIRONMENT = 'production'
                            env.TARGET_EC2_IP = '54.123.45.67'  // Production server IP
                            env.DB_PASSWORD_CREDENTIAL = 'db-password-production'  // Jenkins Credentials: Secret text
                            env.NODE_ENV = 'production'
                            env.DEPLOY_PATH = "${DEPLOY_BASE_PATH}/single-server-3tier-webapp"
                            env.NGINX_SITE_PATH = '/var/www/bmi-health-tracker'
                            env.REQUIRE_APPROVAL = 'true'
                            break
                        
                        case 'staging':
                            env.ENVIRONMENT = 'staging'
                            env.TARGET_EC2_IP = '54.123.45.68'  // Staging server IP
                            env.DB_PASSWORD_CREDENTIAL = 'db-password-staging'  // Jenkins Credentials: Secret text
                            env.NODE_ENV = 'staging'
                            env.DEPLOY_PATH = "${DEPLOY_BASE_PATH}/single-server-3tier-webapp-staging"
                            env.NGINX_SITE_PATH = '/var/www/bmi-health-tracker-staging'
                            env.REQUIRE_APPROVAL = 'false'
                            break
                        
                        case 'develop':
                        case 'dev':
                            env.ENVIRONMENT = 'development'
                            env.TARGET_EC2_IP = '54.123.45.69'  // Development server IP
                            env.DB_PASSWORD_CREDENTIAL = 'db-password-dev'  // Jenkins Credentials: Secret text
                            env.NODE_ENV = 'development'
                            env.DEPLOY_PATH = "${DEPLOY_BASE_PATH}/single-server-3tier-webapp-dev"
                            env.NGINX_SITE_PATH = '/var/www/bmi-health-tracker-dev'
                            env.REQUIRE_APPROVAL = 'false'
                            break
                        
                        default:
                            error "âŒ Unknown branch: ${branch}. Only main/staging/develop are supported."
                    }
                    
                    // Update PM2 process name with environment suffix
                    if (env.ENVIRONMENT != 'production') {
                        env.PM2_PROCESS_NAME = "bmi-backend-${env.ENVIRONMENT}"
                    }
                    
                    // Update backup path
                    env.BACKUP_PATH = "${BACKUP_BASE_PATH}/${env.ENVIRONMENT}"
                    
                    echo "\nâœ… Environment Configuration:"
                    echo "   Environment: ${env.ENVIRONMENT}"
                    echo "   Target Server: ${env.TARGET_EC2_IP}"
                    echo "   Node ENV: ${env.NODE_ENV}"
                    echo "   Deploy Path: ${env.DEPLOY_PATH}"
                    echo "   PM2 Process: ${env.PM2_PROCESS_NAME}"
                    echo "   Nginx Path: ${env.NGINX_SITE_PATH}"
                    echo "   Require Approval: ${env.REQUIRE_APPROVAL}"
                }
            }
        }
        
        stage('Approval for Production') {
            when {
                expression { env.REQUIRE_APPROVAL == 'true' }
            }
            steps {
                script {
                    echo '======================================'
                    echo 'âš ï¸  PRODUCTION DEPLOYMENT APPROVAL REQUIRED'
                    echo '======================================'
                    
                    timeout(time: 1, unit: 'HOURS') {
                        input(
                            message: "Deploy to PRODUCTION environment?\n\nTarget: ${env.TARGET_EC2_IP}\nBranch: ${env.BRANCH_NAME}\nCommit: ${env.GIT_COMMIT}",
                            ok: 'Deploy to Production',
                            submitter: 'admin,ops-team'  // Jenkins user/group authorization
                        )
                    }
                    
                    echo "âœ… Production deployment approved by ${env.BUILD_USER_ID ?: 'user'}"
                }
            }
        }
        
        stage('Checkout Code') {
            steps {
                script {
                    echo '======================================'
                    echo 'ðŸ“¥ CHECKING OUT CODE'
                    echo '======================================'
                    
                    checkout scm
                    
                    sh '''
                        echo "âœ… Code checked out successfully"
                        echo "Branch: ${BRANCH_NAME}"
                        echo "Git commit: $(git rev-parse --short HEAD)"
                        echo "Git message: $(git log -1 --pretty=%B)"
                    '''
                }
            }
        }
        
        stage('Check Prerequisites') {
            steps {
                script {
                    echo '======================================'
                    echo 'ðŸ”§ CHECKING PREREQUISITES'
                    echo '======================================'
                    
                    sshagent([env.EC2_SSH_KEY_ID]) {
                        def checkResult = sh(
                            script: """
                                ssh -o StrictHostKeyChecking=no ${EC2_USER}@${env.TARGET_EC2_IP} '
                                    if [ -d "${env.DEPLOY_PATH}" ]; then
                                        echo "DEPLOYMENT_TYPE=update"
                                    else
                                        echo "DEPLOYMENT_TYPE=fresh"
                                    fi
                                '
                            """,
                            returnStdout: true
                        ).trim()
                        
                        env.DEPLOYMENT_TYPE = checkResult.contains('DEPLOYMENT_TYPE=update') ? 'update' : 'fresh'
                        echo "Deployment Type: ${env.DEPLOYMENT_TYPE}"
                    }
                }
            }
        }
        
        stage('Install Prerequisites') {
            when {
                expression { env.DEPLOYMENT_TYPE == 'fresh' }
            }
            steps {
                script {
                    echo '======================================'
                    echo 'ðŸ“¦ INSTALLING PREREQUISITES'
                    echo '======================================'
                    
                    sshagent([env.EC2_SSH_KEY_ID]) {
                        sh """
                            ssh -o StrictHostKeyChecking=no ${EC2_USER}@${env.TARGET_EC2_IP} '
                                set -e
                                
                                echo "Updating system packages..."
                                sudo apt-get update -qq
                                
                                # Install Node.js via NVM
                                if ! command -v node &> /dev/null; then
                                    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
                                    export NVM_DIR="\$HOME/.nvm"
                                    [ -s "\$NVM_DIR/nvm.sh" ] && . "\$NVM_DIR/nvm.sh"
                                    nvm install --lts
                                    nvm use --lts
                                fi
                                
                                # Install PostgreSQL
                                if ! command -v psql &> /dev/null; then
                                    sudo apt-get install -y postgresql postgresql-contrib
                                    sudo systemctl start postgresql
                                    sudo systemctl enable postgresql
                                fi
                                
                                # Install Nginx
                                if ! command -v nginx &> /dev/null; then
                                    sudo apt-get install -y nginx
                                    sudo systemctl start nginx
                                    sudo systemctl enable nginx
                                fi
                                
                                # Install PM2
                                export NVM_DIR="\$HOME/.nvm"
                                [ -s "\$NVM_DIR/nvm.sh" ] && . "\$NVM_DIR/nvm.sh"
                                if ! command -v pm2 &> /dev/null; then
                                    npm install -g pm2
                                fi
                                
                                echo "âœ… Prerequisites installed"
                            '
                        """
                    }
                }
            }
        }
        
        stage('Setup Database') {
            when {
                expression { !params.DEPLOY_FRONTEND_ONLY }
            }
            steps {
                script {
                    echo '======================================'
                    echo 'ðŸ—„ï¸  SETTING UP DATABASE'
                    echo '======================================'
                    
                    withCredentials([string(credentialsId: env.DB_PASSWORD_CREDENTIAL, variable: 'DB_PASS')]) {
                        sshagent([env.EC2_SSH_KEY_ID]) {
                            // Check if database exists
                            def dbExists = sh(
                                script: """
                                    ssh -o StrictHostKeyChecking=no ${EC2_USER}@${env.TARGET_EC2_IP} '
                                        sudo -u postgres psql -lqt | cut -d \\| -f 1 | grep -qw ${DB_NAME}
                                        echo \$?
                                    '
                                """,
                                returnStdout: true
                            ).trim()
                            
                            if (dbExists == '0') {
                                echo "âœ… Database already exists"
                            } else {
                                echo "Creating database..."
                                sh """
                                    ssh -o StrictHostKeyChecking=no ${EC2_USER}@${env.TARGET_EC2_IP} '
                                        sudo -u postgres psql -c "CREATE USER ${DB_USER} WITH PASSWORD '"'"'${DB_PASS}'"'"';" || true
                                        sudo -u postgres psql -c "CREATE DATABASE ${DB_NAME} OWNER ${DB_USER};" || true
                                        sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE ${DB_NAME} TO ${DB_USER};"
                                        
                                        # Configure authentication
                                        if ! sudo grep -q "local.*${DB_USER}.*md5" /etc/postgresql/*/main/pg_hba.conf; then
                                            echo "local   all   ${DB_USER}   md5" | sudo tee -a /etc/postgresql/*/main/pg_hba.conf
                                            sudo systemctl reload postgresql
                                        fi
                                    '
                                """
                                echo "âœ… Database created"
                            }
                        }
                    }
                }
            }
        }
        
        stage('Create Backup') {
            when {
                expression { env.DEPLOYMENT_TYPE == 'update' }
            }
            steps {
                script {
                    echo '======================================'
                    echo 'ðŸ’¾ CREATING BACKUP'
                    echo '======================================'
                    
                    sshagent([env.EC2_SSH_KEY_ID]) {
                        sh """
                            ssh -o StrictHostKeyChecking=no ${EC2_USER}@${env.TARGET_EC2_IP} '
                                mkdir -p ${env.BACKUP_PATH}
                                cp -r ${env.DEPLOY_PATH} ${env.BACKUP_PATH}/backup_${BUILD_TIMESTAMP}
                                cd ${env.BACKUP_PATH}
                                ls -t | grep "^backup_" | tail -n +6 | xargs -r rm -rf
                                echo "âœ… Backup created"
                            '
                        """
                    }
                }
            }
        }
        
        stage('Deploy Application') {
            parallel {
                stage('Deploy Backend') {
                    when {
                        expression { !params.DEPLOY_FRONTEND_ONLY }
                    }
                    steps {
                        script {
                            echo 'âš™ï¸  Deploying Backend...'
                            
                            // Using Jenkins Credentials Manager for secure credential injection
                            withCredentials([string(credentialsId: env.DB_PASSWORD_CREDENTIAL, variable: 'DB_PASS')]) {
                                sshagent([env.EC2_SSH_KEY_ID]) {
                                    sh """
                                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${env.TARGET_EC2_IP} '
                                            set -e
                                            export NVM_DIR="\$HOME/.nvm"
                                            [ -s "\$NVM_DIR/nvm.sh" ] && . "\$NVM_DIR/nvm.sh"
                                            
                                            # Clone or update repository on target EC2
                                            if [ -d "${env.DEPLOY_PATH}/.git" ]; then
                                                cd ${env.DEPLOY_PATH}
                                                git fetch origin
                                                git reset --hard origin/${env.BRANCH_NAME}
                                            else
                                                # Get repository URL from current workspace
                                                REPO_URL=\$(git config --get remote.origin.url)
                                                git clone -b ${env.BRANCH_NAME} \$REPO_URL ${env.DEPLOY_PATH}
                                            fi
                                            
                                            # Deploy backend
                                            cd ${env.DEPLOY_PATH}/backend
                                            npm install --production
                                            
                                            # Create .env
                                            cat > .env << EOF
DATABASE_URL=postgresql://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}
DB_USER=${DB_USER}
DB_PASSWORD=${DB_PASS}
DB_NAME=${DB_NAME}
DB_HOST=${DB_HOST}
DB_PORT=${DB_PORT}
PORT=${BACKEND_PORT}
NODE_ENV=${env.NODE_ENV}
CORS_ORIGIN=*
EOF
                                            
                                            # Run migrations
                                            for migration in migrations/*.sql; do
                                                [ -f "\$migration" ] && PGPASSWORD=${DB_PASS} psql -U ${DB_USER} -d ${DB_NAME} -h ${DB_HOST} -f "\$migration" || true
                                            done
                                            
                                            # PM2 restart
                                            if pm2 describe ${env.PM2_PROCESS_NAME} > /dev/null 2>&1; then
                                                pm2 restart ${env.PM2_PROCESS_NAME}
                                            else
                                                pm2 start src/server.js --name ${env.PM2_PROCESS_NAME}
                                            fi
                                            pm2 save
                                            
                                            echo "âœ… Backend deployed"
                                        '
                                    """
                                }
                            }
                        }
                    }
                }
                
                stage('Deploy Frontend') {
                    when {
                        expression { !params.DEPLOY_BACKEND_ONLY }
                    }
                    steps {
                        script {
                            echo 'ðŸŽ¨ Deploying Frontend...'
                            
                            sshagent([env.EC2_SSH_KEY_ID]) {
                                sh """
                                    ssh -o StrictHostKeyChecking=no ${EC2_USER}@${env.TARGET_EC2_IP} '
                                        set -e
                                        export NVM_DIR="\$HOME/.nvm"
                                        [ -s "\$NVM_DIR/nvm.sh" ] && . "\$NVM_DIR/nvm.sh"
                                        
                                        cd ${env.DEPLOY_PATH}/frontend
                                        npm install
                                        npm run build
                                        
                                        sudo mkdir -p ${env.NGINX_SITE_PATH}
                                        sudo cp -r dist/* ${env.NGINX_SITE_PATH}/
                                        sudo chown -R www-data:www-data ${env.NGINX_SITE_PATH}
                                        sudo chmod -R 755 ${env.NGINX_SITE_PATH}
                                        
                                        # Configure Nginx if needed
                                        if [ ! -f "/etc/nginx/sites-available/${APP_NAME}-${env.ENVIRONMENT}" ]; then
                                            # Create Nginx config (similar to main Jenkinsfile)
                                            sudo tee /etc/nginx/sites-available/${APP_NAME}-${env.ENVIRONMENT} > /dev/null << EOF
server {
    listen 80;
    server_name _;
    root ${env.NGINX_SITE_PATH};
    index index.html;
    location / { try_files \\\$uri \\\$uri/ /index.html; }
    location /api/ { proxy_pass http://127.0.0.1:${BACKEND_PORT}/api/; }
}
EOF
                                            sudo ln -sf /etc/nginx/sites-available/${APP_NAME}-${env.ENVIRONMENT} /etc/nginx/sites-enabled/
                                        fi
                                        
                                        sudo nginx -t && sudo systemctl reload nginx
                                        echo "âœ… Frontend deployed"
                                    '
                                """
                            }
                        }
                    }
                }
            }
        }
        
        stage('Health Checks') {
            when {
                expression { !params.SKIP_HEALTH_CHECK }
            }
            steps {
                script {
                    echo '======================================'
                    echo 'â¤ï¸  PERFORMING HEALTH CHECKS'
                    echo '======================================'
                    
                    sleep(10)
                    
                    if (!params.DEPLOY_FRONTEND_ONLY) {
                        retry(5) {
                            sh "curl -sf http://${env.TARGET_EC2_IP}:${BACKEND_PORT}/health"
                        }
                        echo "âœ… Backend health check passed"
                    }
                    
                    if (!params.DEPLOY_BACKEND_ONLY) {
                        retry(5) {
                            sh "curl -sf -o /dev/null http://${env.TARGET_EC2_IP}/"
                        }
                        echo "âœ… Frontend health check passed"
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo '======================================'
                echo "âœ… ${env.ENVIRONMENT.toUpperCase()} DEPLOYMENT SUCCESSFUL! ðŸŽ‰"
                echo '======================================'
                echo "Environment: ${env.ENVIRONMENT}"
                echo "Branch: ${env.BRANCH_NAME}"
                echo "Target: http://${env.TARGET_EC2_IP}"
                
                // Send notification based on environment
                if (env.ENVIRONMENT == 'production') {
                    // Production deployment notification
                    // emailext(subject: "âœ… Production Deployment Successful", ...)
                }
            }
        }
        
        failure {
            script {
                echo "âŒ ${env.ENVIRONMENT.toUpperCase()} DEPLOYMENT FAILED!"
                echo "Check logs and consider rollback if needed."
            }
        }
    }
}
